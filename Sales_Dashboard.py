import pandas as pd
import plotly.express as px
import dash
from dash import dcc, html
from dash.dependencies import Input, Output


filepath = '/Users/prachya/Downloads/archive/Balaji Fast Food Sales.csv'

def extraction_data_from_csv(filepath):
    return pd.read_csv(filepath)

def clean_data(df):
    # Remove duplicate rows
    df = df.drop_duplicates()

    # Handle missing values
    df = df.fillna(df.mean(numeric_only=True))

    # Convert 'date' column to datetime
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    
    # Extract the month from the 'date' column
    df['month'] = df['date'].dt.month

    # Create a 'season' column based on the month
    df['season'] = df['month'].apply(get_season)
    
        # Define a list of holiday dates (this can be expanded)
    holiday_dates = [
        '2022-12-25',  # Christmas
        '2023-01-01',  # New Year's Day
        '2022-11-26',  # Thanksgiving (example)
    ]
    # Label each date as 'Holiday' or 'Regular'
    df['is_holiday'] = df['date'].isin(pd.to_datetime(holiday_dates)).map({True: 'Holiday', False: 'Regular'})
    
    # Extract day, month, and year for temporal analysis
    df['day_of_week'] = df['date'].dt.day_name()
    df['month'] = df['date'].dt.month_name()
    df['year'] = df['date'].dt.year
    
    return df
    return df

def get_season(month):
    """Determine the season based on the month."""
    if month in [12, 1, 2]:
        return 'Winter'
    elif month in [3, 4, 5]:
        return 'Spring'
    elif month in [6, 7, 8]:
        return 'Summer'
    elif month in [9, 10, 11]:
        return 'Fall'


# Load and clean the data
raw_data = extraction_data_from_csv(filepath)
cleaned_data = clean_data(raw_data)

# Initialize the Dash app
app = dash.Dash(__name__)

# App layout
app.layout = html.Div([
    html.H1("Sales Dashboard", style={'text-align': 'center'}),

    # Dropdown to select an item
    dcc.Dropdown(
        id='item_dropdown',
        options=[{'label': i, 'value': i} for i in cleaned_data['item_name'].unique()],
        value=cleaned_data['item_name'].unique()[0],  # Default value
        clearable=False,
        style={'width': '50%'}
    ),

  
    # Graph for Sales Trends
    dcc.Graph(id='sales_trend_graph'),

    # Graph for Top-Selling Items
    dcc.Graph(id='top_selling_items_graph'),

    # Pie chart for Transaction Type Distribution
    dcc.Graph(id='transaction_type_pie_chart'),
    
    # Graph for Seasonal Sales Trends
    dcc.Graph(id='seasonal_sales_trend_graph'),
    
    # Graph for Holiday vs Regular Sales Comparison
    dcc.Graph(id='holiday_sales_comparison_graph'),
    
    # Graphs for each question
    dcc.Graph(id='revenue_by_item_type'),         # Total revenue generated by item type
    dcc.Graph(id='highest_sales_volume'),         # Items with highest sales volume
    dcc.Graph(id='most_popular_item'),            # Most popular item in terms of quantity sold
    dcc.Graph(id='avg_transaction_amount'),       # Average transaction amount for each item type
    dcc.Graph(id='quantity_by_time_of_day'),      # Quantity sold by time of day
    
    # Graphs for each question
    dcc.Graph(id='daily_sales_trend'),             # Daily sales trend
    dcc.Graph(id='monthly_sales_trend'),           # Monthly sales trend
    dcc.Graph(id='peak_sales_periods'),            # Peak sales periods for specific items


])

# Callback for sales trend graph
@app.callback(
    Output('sales_trend_graph', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_sales_trend(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Aggregate sales over time
    monthly_sales = filtered_df.groupby(filtered_df['date'].dt.to_period('M'))['transaction_amount'].sum().reset_index()
    monthly_sales['date'] = monthly_sales['date'].astype(str)  # Convert date to string

    # Create line chart for sales trend
    fig = px.line(monthly_sales, x='date', y='transaction_amount', title=f'Sales Trend for {selected_item}')
    fig.update_xaxes(title="Month")
    fig.update_yaxes(title="Sales Amount")
    return fig

# Callback for top-selling items graph
@app.callback(
    Output('top_selling_items_graph', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_top_selling_items(selected_item):
    # Aggregate the total quantity sold for each item
    top_selling = cleaned_data.groupby('item_name')['quantity'].sum().reset_index()
    top_selling = top_selling.sort_values(by='quantity', ascending=False)

    # Create bar chart for top-selling items
    fig = px.bar(top_selling, x='item_name', y='quantity', title='Top-Selling Items')
    fig.update_xaxes(title="Item")
    fig.update_yaxes(title="Quantity Sold")
    return fig

# Callback for transaction type distribution
@app.callback(
    Output('transaction_type_pie_chart', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_transaction_type_pie(selected_item):
    # Filter data based on selected item and group by transaction type
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    transaction_distribution = filtered_df['transaction_type'].value_counts().reset_index()

    # Rename the columns for clarity
    transaction_distribution.columns = ['transaction_type', 'count']

    # Create a pie chart using 'transaction_type' as names and 'count' as values
    fig = px.pie(transaction_distribution, names='transaction_type', values='count', title=f'Transaction Types for {selected_item}')
    return fig


# Callback for seasonal sales trend graph
@app.callback(
    Output('seasonal_sales_trend_graph', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_seasonal_sales_trend(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Group by season and sum the transaction amount
    seasonal_sales = filtered_df.groupby('season')['transaction_amount'].sum().reset_index()
    
    # Sort seasons in order: Winter, Spring, Summer, Fall
    season_order = ['Winter', 'Spring', 'Summer', 'Fall']
    seasonal_sales['season'] = pd.Categorical(seasonal_sales['season'], categories=season_order, ordered=True)
    seasonal_sales = seasonal_sales.sort_values('season')

    # Create bar chart for seasonal sales trends
    fig = px.bar(seasonal_sales, x='season', y='transaction_amount', title=f'Seasonal Sales Trend for {selected_item}')
    fig.update_xaxes(title="Season")
    fig.update_yaxes(title="Sales Amount")
    return fig

# Callback for holiday vs regular sales comparison graph
@app.callback(
    Output('holiday_sales_comparison_graph', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_holiday_sales_comparison(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Group by 'is_holiday' and sum the transaction amount
    sales_comparison = filtered_df.groupby('is_holiday')['transaction_amount'].sum().reset_index()

    # Create bar chart for holiday vs regular sales comparison
    fig = px.bar(sales_comparison, x='is_holiday', y='transaction_amount', title=f'Holiday vs Regular Sales for {selected_item}')
    fig.update_xaxes(title="Type of Day")
    fig.update_yaxes(title="Sales Amount")
    return fig

# Callback for total revenue by item type
@app.callback(
    Output('revenue_by_item_type', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_revenue_by_item_type(selected_item_type):
    # Group by item type and calculate total revenue
    revenue = cleaned_data.groupby('item_type')['transaction_amount'].sum().reset_index()

    # Create a bar chart for total revenue by item type
    fig = px.bar(revenue, x='item_type', y='transaction_amount', title='Total Revenue by Item Type')
    fig.update_xaxes(title="Item Type")
    fig.update_yaxes(title="Total Revenue")
    return fig

# Callback for highest sales volume
@app.callback(
    Output('highest_sales_volume', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_highest_sales_volume(selected_item_type):
    # Group by item name and sum the quantity sold
    sales_volume = cleaned_data.groupby('item_name')['quantity'].sum().reset_index()

    # Create a bar chart for highest sales volume
    fig = px.bar(sales_volume, x='item_name', y='quantity', title='Items with Highest Sales Volume')
    fig.update_xaxes(title="Item Name")
    fig.update_yaxes(title="Total Quantity Sold")
    return fig

# Callback for most popular item
@app.callback(
    Output('most_popular_item', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_most_popular_item(selected_item_type):
    # Find the most popular item by quantity sold
    most_popular = cleaned_data.groupby('item_name')['quantity'].sum().reset_index()
    most_popular = most_popular.sort_values(by='quantity', ascending=False).head(1)

    # Create a bar chart for the most popular item
    fig = px.bar(most_popular, x='item_name', y='quantity', title='Most Popular Item (Quantity Sold)')
    fig.update_xaxes(title="Item Name")
    fig.update_yaxes(title="Quantity Sold")
    return fig

# Callback for average transaction amount by item type
@app.callback(
    Output('avg_transaction_amount', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_avg_transaction_amount(selected_item_type):
    # Group by item type and calculate average transaction amount
    avg_transaction = cleaned_data.groupby('item_type')['transaction_amount'].mean().reset_index()

    # Create a bar chart for average transaction amount by item type
    fig = px.bar(avg_transaction, x='item_type', y='transaction_amount', title='Average Transaction Amount by Item Type')
    fig.update_xaxes(title="Item Type")
    fig.update_yaxes(title="Average Transaction Amount")
    return fig

# Callback for quantity sold by time of day
@app.callback(
    Output('quantity_by_time_of_day', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_quantity_by_time_of_day(selected_item_type):
    # Group by time of sale and sum the quantity sold
    quantity_by_time = cleaned_data.groupby('time_of_sale')['quantity'].sum().reset_index()

    # Create a bar chart for quantity sold by time of day
    fig = px.bar(quantity_by_time, x='time_of_sale', y='quantity', title='Quantity Sold by Time of Day')
    fig.update_xaxes(title="Time of Sale")
    fig.update_yaxes(title="Quantity Sold")
    return fig
# Callback for daily sales fluctuation
@app.callback(
    Output('daily_sales_trend', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_daily_sales(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Group by day of week and sum the transaction amount
    daily_sales = filtered_df.groupby('day_of_week')['transaction_amount'].sum().reset_index()

    # Order the days of the week
    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    daily_sales['day_of_week'] = pd.Categorical(daily_sales['day_of_week'], categories=day_order, ordered=True)
    daily_sales = daily_sales.sort_values('day_of_week')

    # Create bar chart for daily sales trend
    fig = px.bar(daily_sales, x='day_of_week', y='transaction_amount', title=f'Daily Sales Trend for {selected_item}')
    fig.update_xaxes(title="Day of Week")
    fig.update_yaxes(title="Total Sales")
    return fig

# Callback for monthly sales fluctuation
@app.callback(
    Output('monthly_sales_trend', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_monthly_sales(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Group by month and sum the transaction amount
    monthly_sales = filtered_df.groupby('month')['transaction_amount'].sum().reset_index()

    # Order the months
    month_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    monthly_sales['month'] = pd.Categorical(monthly_sales['month'], categories=month_order, ordered=True)
    monthly_sales = monthly_sales.sort_values('month')

    # Create bar chart for monthly sales trend
    fig = px.bar(monthly_sales, x='month', y='transaction_amount', title=f'Monthly Sales Trend for {selected_item}')
    fig.update_xaxes(title="Month")
    fig.update_yaxes(title="Total Sales")
    return fig

# Callback for peak sales periods for specific items
@app.callback(
    Output('peak_sales_periods', 'figure'),
    [Input('item_dropdown', 'value')]
)
def update_peak_sales_periods(selected_item):
    # Filter the data based on the selected item
    filtered_df = cleaned_data[cleaned_data['item_name'] == selected_item]
    
    # Group by both day of the week and month and sum the transaction amount
    peak_sales = filtered_df.groupby(['day_of_week', 'month'])['transaction_amount'].sum().reset_index()

    # Create heatmap for peak sales periods (day vs month)
    fig = px.density_heatmap(peak_sales, x='day_of_week', y='month', z='transaction_amount',
                             title=f'Peak Sales Periods for {selected_item}', nbinsx=7, nbinsy=12)
    fig.update_xaxes(title="Day of Week")
    fig.update_yaxes(title="Month")
    return fig


# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)
    

